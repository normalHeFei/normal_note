###  统一配置管理

> 思路: zk 节点存储配置信息, 配置信息修改,通知客户端更新配置. 
> 实现: spring 可通过自定义 ConfigurableEnvironment 接口实现, 自定义propertySource接口实现

### 同步互斥功能. 

- barrier
   > 多个进程需要等到某一条件满足时,才能开始执行.  如两个任务之间有先后关系,可以考虑使用

实现流程:

1. 首先有个/barrier 的根节点.每个需要同步协同的进程都监听这个根节点
2. 每个进程都创建子节点然后 同步等待 (Object.wait), 
3. 因为其他的进程也是同样的操作(创建子节点), 故每个进程会接收到通知, 收到通知后判断/barrier 下的子节点是否满足了固定数目 
4. 如果满足,则 notify 开始执行. 执行完删除自己之前创建的子节点. 

应用实例:

1. 假想实例: 机器a,b,c 分别部署了三个服务ServiceA, ServiceB, ServiceC. ServiceA 需要 ServiceB, ServiceC 都完成后才能进行.
这个时候就可以使用 barrier.  

- double barrier
  
  > 可以想象 双重barrier 就是在barrier 4 步的基础上, 再加个相似的步骤,如下

实现流程: 

1. 首先有个/barrier 的根节点.每个需要同步协同的进程都监听这个根节点
2. 每个进程都创建子节点然后 同步等待 (Object.wait), 
3. 因为其他的进程也是同样的操作(创建子节点), 故每个进程会接收到通知, 收到通知后判断/barrier 下的子节点是否满足了固定数目 
4. 如果满足,则 notify 开始执行. 执行完删除自己之前创建的子节点. 
5. 删除完节点后,每个process 继续 wait. 
6. 删除节点会收到监听, 如果根节点下的子节点都没了,那就代表全部进程都执行完毕了, 这时再notify 

### lock

zk lock 实现流程:

1. 各个process 创建序列化临时节点.返回序列号名
2. 获取根节点下所有子节点及其序列号
3. 如自己的序列号是最小的及获得锁. 否则wait.并再之前序列最小的节点上添加监听. 监听节点删除,则notifyAll 
4. 释放锁,删除掉锁节点即可. 


注意点: 
1. 锁应该具有超时时间, 如果长时间未被解锁应该自动解锁.
2. 锁应该是可重入的, 避免死锁. 故获取锁时应该保留当前线程信息

其他方式

- 基于数据库
  mysql for update. 

- 基于缓存
  redis.setnx 



### TX 



### 选举
  
方法一

1. 初始化节点 比如 (/election) 
2. 每个服务节点 在 /election 路径下添加监听
3. 每个服务节点乐观的 同时在 /election 根节点下创建同名的 数据临时节点. 如 /leader(noden.example.com)
4. 因为 节点名是相同的 故 同一时刻只有一个节点能够创建成功. 创建成功的即为 leader 节点. 
5. 因为都已经添加了监听. leader 节点创建后,每个子节点都会收到 创建的 leader节点信息. 并各自保存.
6. 如果leader挂掉了, zk与leader节点的session断掉, 那对应的临时节点也就被zk删掉了.其他节点收到通知,重新执行3步骤(重新争夺leader节点),5步骤(更新leader节点信息)
> 缺点: 乐观争夺创建leader节点,容易造成竞争. 不适用于节点多的情况. 

方法二

> 改进思路: 不在每次 leader 挂掉的时候通知所有节点竞争成为leader,而是必要的时候再重新选举,减少竞争

1. 初始化节点 比如 (/election) 
2. 每个服务节点 在 /election 路径下添加监听
3. 每个服务节点 在 /election 路劲下添加 **临时序列** 类型节点, 如(/leader-00001, /leader-00002)
4. 节点通过查询命令, 查询/election 下序列最小的节点即为leader 节点. 
5. leader 挂掉的时候,节点接收通知依次获取当前最小的节点 为 leader 节点. 如 /leader-00001挂掉, 那个接下来就是/leader-00002 为leader节点
6. 如果所有都挂掉的话(即查询根节点, 没有/leader-000x节点),则重新 执行 **步骤3** 
   
### zk 的其他问题

1. 为何需要奇数节点而不是优选偶数节点
   相近奇数节点树和偶数节点数的稳定性是一样的.主要考虑到资源节省. zk有个半数存活特点,即zk集群半数以上机器可用时,这个集群就是稳定的.

### A&Q

A: 获取锁后如果连接丢失,curator 如何处理锁的. 
Q: 丢失连接是添加监听,自己处理. 类似于java 的 interrupted 机制. 这种情况是需要引用端代码考虑的

 